\subsection{Comparison of Basic part indices}

To summarise the comparison of the indices of the basic part, the search and indexing time complexity and space complexity of the indices are gathered in the table \ref{tab:basicpartTimecomplexity}. 

\begin{table}[th!]
\centering
\begin{tabular}{l|ll|ll}
            & Time &     & Memory & \\
    Index & Indexing & Search & Indexing & Search\\
\hline
1 &  $\Theta(n)$                &  $O(n)$  &  $\Theta(n)$   & $O(1)$ \\
2 &  $\Theta(n)$                &  $O(n)$  &  $\Theta(n)$   & $O(a)$         \\
3  &  $O(n\cdot u)$             &  $O(u)$  &  $O(u\cdot a )$ & $O(1)$         \\
4  &  $O(n\cdot \frac{u}{k})$   &  $O(\frac{u}{k})$  &  $O(u\cdot a + k)$ & $O(1)$ \\
5  &  $O(n)$   &  $O(1)$  &  $O(u\cdot a)$ & $O(1)$         
\end{tabular}
\caption{Caption}
\label{tab:basicpartTimecomplexity}
\end{table}

The time complexity of indexing for index2 is analysed to be linear. This tendency is also seen in figure \ref{fig:BPindextime2}.

Index 3 is analysed to have $O(n^2)$ indexing time complexity. It is tricky to declare if figure \ref{fig:BPindextime3} shows that the indexing running time is Linear or quadratic, due to the lack of data points. No additional data points for the indexing time of index3 were provided, as this was very time-consuming. In figure \ref{fig:BPindextime2345} index3 is compared to the other indices of the Basic Part. The figure illustrates how poorly index3 performs compared to the other indices. The architecture of the data structure of index3 was however never predicted to be an effective design compared to hashmaps. 

Index2 is analysed to have a searchtime complexcity of $O(n)$ while index3 has a searchtime complexcity $O(u)$, and is is therefor predicted that index 3 will perform better as $u\leq n$. This is also the tendency seen in \ref{fig:BPsearch23}.

Figure \ref{fig:BPindextime45} shows that the indexing time for index 5 is linear. Index 4 is analysed to have a time complexity of $O(n\cdot \frac{u}{k})$ as index 4 has a static hash map where all entries at some point can be used, meaning that multiple words share the same hash key. This slows down the indexing time tremendously. 
In figure \ref{fig:BPindextime45}, index 5 performs much better than index4. This is due to the fact that index 5 uses a dynamic hash map. 

 Index 4 is analysed to have a time complexity of $O(\frac{u}{k})$ as multiple words share the same hash key, which it then has to search through linearly. This slows down the searching time tremendously. In figure \ref{fig:BPsearch23}, it is seen that index5 searches in constant time, which once again shows the benefits of a dynamic hashmap.

 As it is seen in table \ref{tab:basicpartTimecomplexity}, index 5 is superior compared to the other indices when it comes to search time complexity. Furthermore, it does also manage to perform well in memory usage and indexing time. This is also the tendency seen from the timing of the data. Index 5 is therefore by far the superior index in the basis part of the project.  

