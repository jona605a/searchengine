\section{Discussion}
When looking at figure \ref{fig:IndexingBoolPrefi} it is seen that all indexing times are linear in time complexity but with different constants. Index9.0 and Index9.1 are slower than the Boolean indices. This is expected as the indexing time of Index7 and Index8 only needs to process each word, whereas Index9.0 and Index9.1 process all characters in the text and manage a larger data structure.

Index9.1 has the indexing time complexity of $O(n)$ whereas index Index9.0 runs in $O(n\cdot \Sigma)$. Index9.0 is however indexing much faster than Index9.1 when looking at \ref{fig:IndexingBoolPrefi}. It is a well-known problem in RUST that hash maps may perform slowly. This is due to the complicated cryptographic hash function designed to prevent hash table collision attacks \cite{RustLang}. We were not aware of this property, which is non-necessary in our case when designing the Index and we would in hindsight have chosen another hash function. The indexing time of Index9.1 thereby has great potential of improving by experimenting with simpler Hash functions such as the RUST Fowler–Noll–Vo function\cite{FNV} or the function \ref{eq:hashfunc} described in Index4. As Index9.1 has to calculate a complicated Hash value for each character in each file, this may be the course of the slow indexing time.

When indexing files consisting of English text, $O(n\cdot \Sigma)$ is a generous overestimate, as it is very unlikely that the number of children of an internal node of the trie nodes is anywhere near the size of the whole alphabet. Table \ref{tab:triecount} shows the data collected from counting the number of children in each layer of the trie for all file sizes. Note that all averages are calculated using all nodes except leaves. 

\begin{table}[ht!]
\centering
\begin{tabular}{l|lllllll}
 File size & \#nodes      & Avg \#c  & Max \#c  & Avg \#c & Avg \#c & Avg \#c & Percent          \\
 (MB)     & in trie     & in trie  &  in trie  & layer 0 & layer 1 & layer 2 & only-children   \\\hline
 0.1      & 15021   & 1.27 & 75   & 75       & 6.41     & 2.87     & 65.3\%                   \\
 1        & 80400   & 1.30 & 115  & 115      & 10.45    & 4.06     & 62.2\%             \\
 2        & 123987  & 1.31 & 183  & 183      & 8.49     & 4.29     & 61.9\%             \\
 5        & 230710  & 1.31 & 266  & 266      & 8.43     & 4.41     & 61.8\%             \\
 10       & 363212  & 1.32 & 415  & 415      & 7.43     & 4.41     & 61.4\%             \\
 20       & 578149  & 1.32 & 590  & 590      & 7.17     & 4.54     & 61.5\%             \\
 50       & 1022511 & 1.33 & 1055 & 1055     & 5.89     & 4.56     & 61.6\%             \\
 100      & 1608908 & 1.33 & 1730 & 1730     & 5.14     & 4.42     & 61.6\%             \\
 200      & 2527603 & 1.33 & 2409 & 2409     & 4.99     & 4.50     & 61.7\%             \\
\end{tabular}
\caption{Statistics for the number of children in each trie. \#nodes in trie denotes the total number of nodes, including accepting nodes. The averages presented in all other columns are calculated using all other nodes than leaves. Layer 0 is defined to be the root. Only-children are nodes with no siblings. \#c is short for \textit{Number of children}. }
\label{tab:triecount}
\end{table}

From table  \ref{tab:triecount} it is seen that the average number of children per node in all tries is $\approx 1.3$. It is important to keep in mind that there is a large difference in the number of children in the first layers to this mean point estimate, meaning that the number of children in the first layers of the nodes increases the average.  There are $\approx 61\%$ of nodes that are only children. This means that Index9.0 only needs to go through a list of length 1 before traversing $\approx 61\%$ of the nodes of the tree, which are great conditions for linear search. Index9.1 does however still need to calculate the hash value for a character to traverse these nodes. When inserting or searching for a word both indices need to start at the root. As it is the root of the node that has the most children, Index9.1 has a great advantage here as Index9.0 needs to linear search through the list of children.

When searching for a prefix consisting of 3 characters Index9.1 is therefore faster than Index9.0 as seen in figure\ref{fig:SearchtimePrefix}. This is due to the fact that both indices has to traverse the three first layers of the trie, which in average have the most children. The reason why the search function grows linearly in figure \ref{fig:SearchtimePrefix} is because both indices have to evaluate the sub trie below the node that the prefix leads to. Evaluating the sub trie takes $O(d\cdot a)$ for both Indexes. The number of accepting nodes on the sub trie and naturally grows with file size. 

To improve the look-up of children of nodes in Index9.0, keeping the list of children for each node sorted could be beneficial. This could be done by storing children in a linked list, where new children then could be inserted at the right place rather than at the end of the list. Index9.0 already traverses the list of children, before inserting a new one to make sure that the children are not in the list already. By keeping the list of children sorted this traversal would take $O(|\Sigma|)$ instead of $\Theta(|\Sigma|)$. Both indexing time and search time might thereby be improved by implementing this extension.

As the mean number of children per node is less than two and the percentage of only children is $\approx 61\%$, a compact trie would be a good addition to reduce the space requirements of the index. Further work could show how much of an improvement this could have resulted in. 
