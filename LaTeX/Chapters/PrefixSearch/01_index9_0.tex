\section{Index9.0}
Index9.0 supports prefix search, as it uses a trie as its data structure. 

In Index9.0, each node is a struct containing three fields: a character corresponding to the label on that node, a linked list containing the children it has, and an optional linked list of the articles in which the word ending in this node is present.

The construction of the trie is done by following the steps in section \ref{sec:Constructiontire}, where the data structures for storing the children is an array.

Step 3-4 takes $O(\Sigma)$ time, as it has to iterate through the list of children to see if the character exist. The length of the list of children is bounded by $|\Sigma|$ and is implemented in practice as a dynamic vector. The construction of Index9.0 thereby runs in $O(n\cdot|\Sigma|)$ time, as all characters of the text need to be evaluated by step 3 or 4.

Index9.0 uses $O(p + u\cdot a)$ space, where $p$ is the number of prefixes in the input file. $p$ thereby represents all the nodes in the trie and $ u\cdot a$ represents the $u$ end nodes and their belonging article list of length $O(a)$.

\subsection{Search techniques for Index9.0}
Given a query, the search function simply traverses its way through the trie, according to the next character in the query, starting at the root node. If the next character of the query is not a child of the current node or if there are no characters left of the query, and the article list of the current node does not exist, then the function replies that the query not was found in the database. If the article list exists, then the index simply returns the article list. It is thereby possible to search for single complete words in the database.

Searching for a single complete word in the index takes $O(q\cdot |\Sigma|)$, where $q$ is the number of characters in the query, as it is necessary to search for characters in $q$ different lists. 

If the next character is "*" the index returns the union of all the article lists of the end nodes of the sub trie starting in the current node. To calculate this union, the sub trie is recursively traversed. When traversing the sub trie, if a node has an article list, the article list is transformed into an article bit vector. Then the bit wise OR operation from Index8.4 is used to calculate the union.

Searching for a prefix in the index takes $O(q\cdot |\Sigma| + \$ \cdot a)$ time. It is still necessary to traverse the trie to find the node where the prefix ends. This takes $O(q\cdot |\Sigma|)$ time. It takes $\Theta(a)$ time to transform an article list into a article bit vector, and we need to transform $\$$ of them, where $\$$ is the number of accepting nodes in the sub trie. Performing the bit wise OR operation takes $\Theta(a)$ time. Performing the bit wise operation $\$-1$ times then takes $O(a \cdot \$)$ time. In total the prefix search thereby takes $O(q\cdot |\Sigma| + d\cdot a + \$\cdot a) = O(q\cdot |\Sigma| + \$\cdot a)$ time. 

 
